# 内存泄漏

系统进程不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。当内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。Chrome 限制了浏览器所能使用的内存极限（64 位为 1.4GB，32 位为 1.0GB）

### 引起内存泄漏的原因

#### 1、意外的全局变量引起的内存泄漏。

- 未声明变量

```js
function fn() {
  a = "Actually, I'm a global variable"
}
fn()
```

- 使用 this 创建的变量(this 的指向是 window)。

```js
function fn() {
  this.a = "Actually, I'm a global variable"
}
fn()
```

解决方法：

- 避免创建全局变量
- 使用严格模式,在 JavaScript 文件头部或者函数的顶部加上 `use strict`。

#### 2、闭包引起的内存泄漏

原因：闭包可以维持函数内局部变量，使其得不到释放。

```JS
function fn () {
  var a = "I'm a";
  return function () {
    console.log(a);
  };
}
```

解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对 dom 的引用。

#### 3、没有清理的 DOM 元素引用

原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用。

```js
// 在对象中引用DOM
var elements = {
  btn: document.getElementById('btn'),
}
function doSomeThing() {
  elements.btn.click()
}

function removeBtn() {
  // 将body中的btn移除, 也就是移除 DOM树中的btn
  document.body.removeChild(document.getElementById('button'))
  // 但是此时全局变量elements还是保留了对btn的引用, btn还是存在于内存中,不能被GC回收
}
```

解决方法：手动删除，`elements.btn = null`。

#### 4、被遗忘的定时器或者回调

定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。

```js
// 定时器
var serverData = loadData()
setInterval(function () {
  var renderer = document.getElementById('renderer')
  if (renderer) {
    renderer.innerHTML = JSON.stringify(serverData)
  }
}, 5000)

// 观察者模式
var btn = document.getElementById('btn')
function onClick(element) {
  element.innerHTMl = "I'm innerHTML"
}
btn.addEventListener('click', onClick)
```

解决方法：

- 手动删除定时器和 dom。
- removeEventListener 移除事件监听

#### 5、子元素存在引用引起的内存泄漏

原因：div 中的 ul li 得到这个 div，会间接引用某个得到的 li，那么此时因为 div 间接引用 li，即使 li 被清空，也还是在内存中，并且只要 li 不被删除，他的父元素都不会被删除。

### vue 中容易出现内存泄露的几种情况

#### 1、全局变量造成的内存泄露

声明的全局变量在切换页面的时候没有清空

```html
<template>
  <div id="home">这里是首页</div>
</template>

<script>
  export default {
    mounted() {
      window.test = {
        // 此处在全局window对象中引用了本页面的dom对象
        name: 'home',
        node: document.getElementById('home'),
      }
    },
  }
</script>
```

解决方案:在页面卸载的时候顺便处理掉该引用。

```js
destroyed () {
  window.test = null // 页面卸载的时候解除引用
 }
```

#### 2、监听在 window/body 等事件没有解绑

特别注意 window.addEventListener 之类的时间监听

```js
<template>
<div id="home">这里是首页</div>
</template>

<script>
export default {
mounted () {
  window.addEventListener('resize', this.func) // window对象引用了home页面的方法
}
}
</script>
```

解决方法:在页面销毁的时候，顺便解除引用，释放内存

```js
mounted () {
  window.addEventListener('resize', this.func)
},
beforeDestroy () {
  window.removeEventListener('resize', this.func)
}
```

#### 3、绑在 EventBus 的事件没有解绑

举个例子

```js
<template>
  <div id="home">这里是首页</div>
</template>

<script>
export default {
  mounted () {
   this.$EventBus.$on('homeTask', res => this.func(res))
  }
}
</script>
```

解决方法:在页面卸载的时候也可以考虑解除引用

```js
mounted () {
 this.$EventBus.$on('homeTask', res => this.func(res))
},
destroyed () {
 this.$EventBus.$off()
}
```

#### 4、Echarts

每一个图例在没有数据的时候它会创建一个定时器去渲染气泡，页面切换后，echarts 图例是销毁了，但是这个 echarts 的实例还在内存当中，同时它的气泡渲染定时器还在运行。这就导致 Echarts 占用 CPU 高，导致浏览器卡顿，当数据量比较大时甚至浏览器崩溃。

解决方法：加一个 beforeDestroy()方法释放该页面的 chart 资源，我也试过使用 dispose()方法，但是 dispose 销毁这个图例，图例是不存在了，但图例的 resize()方法会启动，则会报没有 resize 这个方法，而 clear()方法则是清空图例数据，不影响图例的 resize，而且能够释放内存，切换的时候就很顺畅了。

```js
beforeDestroy () {
  this.chart.clear()
}
```

#### 5、v-if 指令产生的内存泄露

v-if 绑定到 false 的值，但是实际上 dom 元素在隐藏的时候没有被真实的释放掉
